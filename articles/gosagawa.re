= Goのエラーハンドリングを深掘りする

== 概要

アプリケーションを実装するにあたり、エラーハンドリングは非常に重要です。しかし、エラー管理がデフォルトでは非常にシンプルです。カスタマイズをしなければ不便であるところは欠点でありつつもの、逆にしっかりとカスタマイズをすれば非常に強力なツールとなりえます。この記事ではpkg/errorsライブラリや、GopherCon2019のセッション"Handling go errors",そしてAthensプロジェクトでのエラーハンドリングの
実例を通して、実用にみあったエラーハンドリング処理の書き方をお伝えできればと思っています。

== エラーハンドリングで満たしたい要件

Goのエラーハンドリングの良いところでもあり大変なところでもあるのは、カスタマイズがしやすく設計が必要であるという事だと思います。
何もせず、そのままreturn errを繰り返すだけだとエラーのテキスト情報のみしか受け渡す事ができません。

では、実際の業務でエラーハンドリングに求められる要件はどのような事があるでしょうか？

Webアプリケーションを例に取った時、以下がよくある要件なのではと思います。

* エラーを階層構造でもち、オリジナルのエラーと最後にラップしたエラー含めていずれの階層のエラーも取得できる
* 問題の発生箇所のファイル、関数名、行数を確認できる
* エラーの種類、ログレベル、エラーコード、レスポンスコードを保持できる
* アプリケーション固有の情報を保持できる

一つ一つみていきましょう。
* エラーを階層構造でもち、オリジナルのエラーと最後にラップしたエラー含めていずれの階層のエラーも取得できる

簡単なプログラムでない限り、エラーは階層化されていくかと思います。例えば、ログイン処理でユーザ取得時にDB接続に失敗した場合
DB接続エラー、ユーザ取得エラー、ログインエラーと階層化されます。こうなった時にログインエラーだけわかっても何が原因かわかりませんし、
DB接続エラーだけみてもそれがどのような影響をるのかわからないため必要になるかと思い明日。

* 問題の発生箇所のファイル、行数を確認できる
エラーが発生したら、発生箇所のコードを追う事になるので欲しい情報です。なお、階層化された場合階層化されたエラーそれぞれの発生箇所がわかるのが望ましいです。

* エラーの種類、ログレベル、エラーコード、レスポンスコードを保持できる
エラーハンドリングをやる目的の一つとして、エラーによって処理を分けたいという事があるかと思います。
エラーの種類によって特定の処理を行う、ログレベル(例:Debug,Info,Warning)を判定してログを出し分ける、レスポンスを返す際エラーコードを付与したり、レスポンスコード(例:200,404,500)を変更したり等これらがパラメータとして必要になることかと思います。

* アプリケーション固有の情報を保持できる
時として、エラーは特定のシチュエーションのみでしか発生しない事があります。例えば、特定のユーザのみ発生するエラーがあった場合、ユーザ情報をエラーと一緒に保持しておくとデバッグが容易になります。
エラーメッセージ内に持たせる事もできるのですが、エラーの可読性を落としたりシステムで何か処理をしたい場合は別に持っている事が望ましいです。
また、ログとして記録するエラーと実際にユーザに表示されるエラーは異なるものになるかと思います。例えば、記録したいエラーが「ユーザ(%v):ポイント不足で購入不可」、表示させたいエラーが「ポイント不足で購入ができません。現在の保持ポイント:%v」というような形だった場合、ユーザIDと所持ポイントを持っておくと、エラー処理時に出力が容易になります。

== pkg/errorsを使ったエラーハンドリング

業務で書いてみた。
→エラーが追いづらいので階層化はした
→うまく階層化されておらず、２階層下のエラー情報が取れない
→pkg/errorsで書き直した。

== pkg/errorsできることを正しく理解する
=== pkg/errorsライブラリできること
=== pkg/errorsはどのように階層化したエラーの起点のエラーを取得しているか
=== pkg/errorsはどのようにスタックトレースをとっているか
=== pkg/errorsライブラリできないこと

== error handling in goで述べられていた解決策

== athensのエラーハンドリング

== まとめ

== 参考

