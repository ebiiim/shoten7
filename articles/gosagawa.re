= Goのエラーハンドリングを深掘りする

== 概要

アプリケーションを実装するにあたり、エラーハンドリングは非常に重要です。しかし、エラー管理がデフォルトでは非常にシンプルです。カスタマイズをしなければ不便であるところは欠点でありつつもの、逆にしっかりとカスタマイズをすれば非常に強力なツールとなりえます。この記事ではpkg/errorsライブラリや、GopherCon2019のセッション"Handling go errors",そしてAthensプロジェクトでのエラーハンドリングの
実例を通して、実用にみあったエラーハンドリング処理の書き方をお伝えできればと思っています。

== エラーハンドリングで満たしたい要件

Goのエラーハンドリングのよいところでもありたいへんなところでもあるのは、カスタマイズがしやすく設計が必要であるということだと思います。
何もせず、そのままreturn errを繰り返すだけだとエラーのテキスト情報のみしか受け渡すことができません。

では、実際の業務でエラーハンドリングに求められる要件はどのようなことがあるでしょうか。

Webアプリケーションを例に取った時、よくある要件として以下があげられます。

* エラーを階層構造でもち、オリジナルのエラーと最後にラップしたエラー含めていずれの階層のエラーも取得できる
* 問題の発生箇所のファイル、関数名、行数を確認できる
* エラーの種類やログレベル、エラーコード、レスポンスコードなどを保持できる
* アプリケーション固有の情報を保持できる

1つひとつみていきましょう。
* エラーを階層構造でもち、オリジナルのエラーと最後にラップしたエラー含めていずれの階層のエラーも取得できる

簡単なプログラムでない限り、エラーは階層化されていくかと思います。たとえ、ログイン処理でユーザー取得時にDB接続に失敗した場合
DB接続エラー、ユーザー取得エラー、ログインエラーと階層化されます。こうなった時にログインエラーだけわかっても何が原因かわかりませんし、
DB接続エラーだけみてもそれがどのような影響をるのかわからないため必要になるかと思い明日。

* 問題の発生箇所のファイル、行数を確認できる
エラーが発生したら、発生箇所のコードを追うことになるのでほしい情報です。なお、階層化された場合階層化されたエラーそれぞれの発生箇所が分かるのが望ましいです。

* エラーの種類やログレベル、エラーコード、レスポンスコードなどを保持できる
エラーハンドリングをやる目的のひとつとして、エラーによって処理を分けたいということがあるかと思います。
エラーの種類によって特定の処理を行う、ログレベル（例:Debug,Info,Warning）を判定してログを出し分ける、レスポンスを返す際エラーコードを付与したり、レスポンスコード（例:200,404,500）を変更したり等これらがパラメータとして必要になることかと思います。

* アプリケーション固有の情報を保持できる
時として、エラーは特定のシチュエーションのみでしか発生しないことがあります。たとえ、特定のユーザーのみ発生するエラーがあった場合、ユーザー情報をエラーと一緒に保持しておくとデバッグが容易になります。
エラーメッセージ内に持たせることもできるのですが、エラーの可読性を落としたりシステムで何か処理をしたい場合は別に持っていることが望ましいです。
また、ログとして記録するエラーと実際にユーザーに表示されるエラーは異なるものになるかと思います。たとえ、記録したいエラーが「ユーザー（%v）:ポイント不足で購入不可」、表示させたいエラーが「ポイント不足で購入ができません。現在の保持ポイント:%v」というような形だった場合、ユーザーIDと所持ポイントを持っておくと、エラー処理時に出力が容易になります。

== pkg/errorsを使ったエラーハンドリング

業務で書いてみた。
→エラーが追いづらいので階層化はした
→うまく階層化されておらず、２階層下のエラー情報が取れない
→pkg/errorsで書き直した。

エラーを階層化してもているということで最初はpkg/errorsを使ったエラーハンドリングを検討しました。

ToDo コード貼る

上記のコードでエラーをラップできてそうですが実際はエラー文言を引き継いでいるだけで、２段階前のエラー情報を階層として持たすことができません。
pkg/errorsを使5つエラーを階層化して保持できないだろうかということを考えるにあたり、pkg/errosをより深掘りしていきます

== pkg/errorsの動作とできることを理解する

pkg/errorsは非常にシンプルなライブラリで、ファイルも数ファイルのみでコードも読みやすいです。実際に読んでみると次の機能に集約されることがわかります。

* エラー内容を階層化して保存する
* スタックトレースを取得する

それぞれの機能は次のように実現されています
* エラー内容を階層化して保存するA
エラーは図に示すような構造体となって階層状に保存されていきます。

WithMessageはCause（)というcauseを返す関数を持ちます。Caseu(）関数をもつcauserインタフェースを定義し、errがcauserに変換できるかを再帰処理で調べていき、オリジナルのエラーはCause()関数を持たないため、それでオリジナルのエラーを判別できます。

//list[Cause][階層化したエラーのオリジナルを取得する関数][go]
func Cause（err error） error {
	type causer interface {
		Cause() error
	}

	for err != nil {
		cause, ok := err.（causer）
		if !ok {
			break
		}
		err = cause.Cause()
	}
	return err
}
//}

* スタックトレースを取得する
スタックトレースは、ファイル名と関数名、行数で構成されていますが
それぞれruntimeパッケージを利用することで取得することが可能です。
シンプルにruntimeパッケージを使って情報を取得するには次のような関数になります。


//list[runtime][ランタイムパッケージを使用した情報取得][go]
package main

import (
	"fmt"
	"runtime"
)

func main() {

    const depth = 32
    var pcs [depth]uintptr
    n := runtime.Callers（0, pcs[:]）

    var st []uintptr = pcs[0:n]
    for _, f := range st {
        fn := runtime.FuncForPC（f）
        file, LINE := fn.FileLine（f）
        fmt.Println（fn.Name(）,file, LINE)
    }
}
//}

これをGo Playground上で動かすと（https://play.golang.org/p/CN09KGDu6UC）

//emlist[][]{
runtime.Callers /usr/local/go/src/runtime/extern.go 211
main.main /tmp/sandbox099384991/prog.go 12
runtime.main /usr/local/go/src/runtime/proc.go 212
runtime.goexit /usr/local/go/src/runtime/asm_amd64p32.s 523
//}
となり、しっかりruntime.Callerを読んだ場所と、runtime.Callerを呼んでいる関数が取得できます。
pkg/errorsでも同様にruntimeパッケージを利用して、情報を取得し整形してスタックトレースとしています。

以上がpkg/errorsの挙動となりますが、これを踏まえると階層化しているデータはメッセージのみなのでそれ以外の情報を持たせるようにし、スタックトレースを取る機能はpkg/errorを使わずにruntimeパッケージをそのまま使うことにより実現ができそうです。

== error handling in goで述べられていた解決策

== athensのエラーハンドリング

== まとめ

== 参考

